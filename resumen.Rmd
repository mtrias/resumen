---
title: "Resumen de R para el Curso de Estadistica Descriptiva 2025"
output:
  html_notebook:
    css: styles.css
---

```{r echo=FALSE}
library("dplyr")
library("dslabs")
data('murders')
```

## Render y Preview de Notebooks

Existe la opcion de previsualizar en panel "viewer" de RStudio o en una ventana separada. Buscar en:
```
Tools -> Global Options -> R Markdown -> Show Output Preview In
```

| Atajos de Teclado de RStudio               |            | ⊞           |
|:-------------------------------------------|:------------|:------------|
| Ejecutar el chunk en el que esta el cursor | `⌘ + ⇧ + ⏎` | `⌘ + ⇧ + ⏎` |
| Agregar un nuevo chunk de R                | `⌘ + ⌥ + i` | `⌘ + ⌥ + i` |
| Previsualizar                              | `⌘ + ⇧ + k` | `⌘ + ⇧ + k` |
| Ventana de atajos de teclado               | `⌥ + ⇧ + k` |             |
| Ejecutar linea en la que esta el cursor    | `⌘ + ⏎`     ||
| Ejecutar todo el script                    | `⌘ + ⇧ + ⏎` ||
| Ejecutar todo el script sin eco            | `⌘ + ⇧ + s` ||


[Cheatsheet de R Notebooks](https://posit.co/blog/the-r-markdown-cheat-sheet/)



## Consola de R Studio

valor de retorno del ultimo comando ejecutado
`.Last.value`



## Paquetes y Datasets
```{r eval=FALSE}
install.packages("uno")
install.packages(c("uno","dos"))
library(uno)
```

La funcion `data()` muestra la lista de paquetes de datos de ejemplo disponibles. Cargamos una libreria (paquete) con `library(nombre_del_paquete)` y luego cargamos un set de datos del paquete con `data(nombre_del_set)`

Los paquetes existen en un `namespace` y los objetos dentro de los diferentes paquetes a veces pueden tener el mismo nombre. En caso de colisiones R sigue un orden de busqueda que se puede ver con:

```{r}
search()
```

Si queremos invocar a un objeto en un namespace particular usamos el prefijo `namespace::`

## Funciones

`log(8,2)` es equivalente a `log(8, base=2)` ya que los argumentos se asumen en orden si el nombre no es especificado. Ver orden de argumentos usando `args(funcion)`

### Funciones para explorar funciones
```{r eval=FALSE}
help(function)
?function
args(function)
```

### Funciones para trabajar con vectores
```{r}
x <- c(31, 4, 92, 15, 65)
max(x)
min(x)
which.max(x)
which.min(x)
```
### Funciones para examinar objetos
```{r eval=FALSE}
str(objeto)
head(objeto-tipo-matriz)
View(objeto-tipo-matriz)
names(objeto)
length(objeto)
dim(objeto-tipo-matriz)
levels(factor)
```



### Definicion de funciones

```{r eval=FALSE}
avg <- function(x) {
  s <- sum(x) # variable local
  n <- length(x)
  s/n # valor de retorno
}
```

Ejemplo con argumentos multiples
```{r eval=FALSE}
avg <- function(x, arithmetic=TRUE) {
  n <- length(x)
  ifelse(arithmetic, sum(x)/n, prod(x)^(1/n))
}
```



## Tipos de Datos
|                 Ejemplo |   class(a) |
| -----------------------:|:-----------|
|                    `1L` |   integer  |
|                    `8`  |   numeric  |
|                   `"8"` |      char  |
|                  `TRUE` |   logical  |
|                `c(8,9)` |    vector  |
|  `factor(LETTERS[1:5])` |   factors  |
| `list(name="Juan",...)` |     lists  |
|      `matrix(1:8, 2,4)` |     matrix |
|       `data(gapminder)` | data.frame |
               


## Vectors

```{r}
x <- c(404, 500, 501)
class(x)

codes <- c(italy=380, canada=124, egypt=818)
str(codes)

codes[2]
codes[c(1,3)]
codes[1:2]
codes["canada"]
codes[c("egypt","italy")]
names(codes)
length(codes)
```

se pueden asignar nombres a un vector usando la funcion names
```{r} 
codes <- c(380, 124, 818)
country <- c("italy", "canada", "egypt")
names(codes) <- country
str(codes)
```



## Factors
```{r}
class(murders$region)
levels(murders$region)
length(murders$region)
table(murders$region)
```

Por defecto los niveles se ordenan alfabeticamente, pero se pueden reordenar usando la funcion `reorder`, la cual en este ejemplo hace lo mismo que `rank` pero al revez.

```{r}
letras <- factor(LETTERS[1:5])
levels(letras)
numeros <- c(3, 4, 5, 2, 1)
letras <- reorder(letras, numeros)
levels(letras)
```

Reordenar factor por una columna
```{r}
region <- murders$region
value <- murders$total
region <- reorder(region, value, FUN = sum)
levels(region)
```



## Lists
```{r}
record <- list(name="John", student_id=8, grades=c(94,24,64), final="A")
record$student_id
record[["student_id"]]
```

Tambien pueden haber listas con variables sin nombre. en cuyo caso no se puede utilizar `$` para acceder.

```{r}
record <- list("Juan", 8)
record[[1]]
```



## Matrix
Las entradas de una matriz deben ser todas del mismo tipo.
```{r}
mat <- matrix(LETTERS[1:12], 4, 3)
mat[2, 3]
mat[2, ]
mat[ ,3]
mat[, 2:3]
mat[1:2, 2:3]
as.data.frame(mat)
```



## DataFrames
```
View(dataframe)
```


## Secuencias

Generador de Secuencias (funcion y operador)
```{r}
1:5 # integer
seq(1,10,2) # integer
seq(1,4,0.5) # numeric
```



## Conversiones
```{r eval=FALSE}
as.integer
as.character
as.numeric
```



## Sorting (sort, order, rank)

Ordenando con `sort`
```{r}
x <- c(31, 4, 15, 92, 65)
sort(x)
```

Ordenando con `order`
```{r eval=FALSE}
chars <- c("a", "c", "e", "b", "d")
idx <- order(chars) #  1   4   2   5   3
chars[idx]          # "a" "b" "c" "d" "e"
```

### Comparacion de Funciones de Ordenacion

Dado el vector desordenado: `x  <- c(31, 4, 15, 92, 65)`

| funcion    |    valor retorno | Descripcion                              |
| ---------: | ---------------: | ---------------------------------------- |
|   `str(x)` | `31  4 15 92 65` |                                          |
|  `sort(x)` | ` 4 15 31 65 92` | los valores ordenados                    |
| `order(x)` | ` 2  3  1  5  4` | las posiciones de los elementos en orden |
|  `rank(x)` | ` 3  1  2  5  4` | el ranking del elemento en cada posicion |



## Indexing

### Which, Match, %in%

```{r eval=FALSE}
ind <- which(murders$state == "California")
ind <- match(c("New York", "Florida", "Texas"), murders$state)
c("Boston", "Dakota", "Florida") %in% murders$state # FALSE FALSE TRUE
```

```{r eval=FALSE}
states <- c("Florida", "Texas")

# Son equivalentes:
match(states, murders$state)
which(murders$state %in% states)
```

### Indexacion con logicals
```{r eval=FALSE}
murder_rate <- murders$total / murders$population * 1e5
```

Equivalentes pero distintos
```{r eval=FALSE}
# retorna vector logico del mismo tamaño que murder_rate
ind <- murder_rate < 0.71 
murders$state[ind]

# retorna vector solamente con los indices que satisfacen
ind <- which(murder_rate < 1)
murders$state[ind]
```



## Graficos Basicos ([cap 2.15](https://rafalab.dfci.harvard.edu/dslibro/r-basics.html#gráficos-básicos))

```{r}
x <- murders$population / 10^6
y <- murders$total
plot(x, y)
```
Sintaxis abreviada con `with`
```{r eval=FALSE}
with(murders, plot(population, total))
```

```{r}
with(murders, hist(total / population * 1e5))
```
Faltan incluir: `Image` y `Boxplot`



## Conceptos Basicos de Programación ([cap 3](https://rafalab.dfci.harvard.edu/dslibro/conceptos-básicos-de-programación))

### Expresiones Condicionales
```{r eval=FALSE}
if (condicion-logica) {
  # acciones si condicion-logica es TRUE
} else {
  # acciones si condicion-logica es FALSE
}
```

Tambien existe en la version funcion: `ifelse(num > 0, 1/num, NA)`

```{r}
z <- c(TRUE, TRUE, FALSE)
any(z)
all(z)
```


### Bucles

```{r}
for (i in 1:5) { print(i) }
```



# TidyVerse ([cap 4](https://rafalab.dfci.harvard.edu/dslibro/tidiverse.html))

## Manipulacion de Data Frames con paquete `dplyr`

Observar que todas las funciones de `dplyr` agregan la funcionalidad de `with`
```{r}

# Agregar columnas
murders <- mutate(murders, rate = total / population * 1e6)

# Crear subconjuntos
filter(murders, rate <= 0.71)

# Seleccionar columnas
newTable <- select(murders, state, region, rate)
```



## Pipe
```{r}
# Equivalente a log2(sqrt(16))
16 |> sqrt() |> log(base=2)

murders |> select(state, region, rate) |> filter(rate <= 0.71)
```


## Summarize
